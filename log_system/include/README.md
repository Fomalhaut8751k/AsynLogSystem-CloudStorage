# AsyncWorker
## 生产者和消费者模式：
- 逻辑图：

    ![](img/AsyncWorker.png)

- 如何交换生产者和消费者的缓冲区？

    ————使用指针

    ```cpp
    std::shared_ptr<AsyncBuffer> buffer_productor_;
    std::shared_ptr<AsyncBuffer> buffer_consumer_;
    ```
    
- 安全模式和非安全模式

    **安全模式**：缓冲区有一定的大小，当写满时，生产者将不再允许用户数据写入，直到其他日志内容被消费掉

    **非安全模式**：缓冲区的大小可变，允许缓冲区增长，但可能导致缓冲区过大而内存不足，一般只用于测试

    

## 日志管理系统第一版：
- 逻辑图：

    ![](img/process1.png)

    在ASyncLogger中，使用`libevent`来模拟异步日志系统接受到日志信息：客户端向服务器发送信息，视为日志，服务器接受到日志后发送到生产者的缓冲区，生产者因为消费者空闲以及缓冲区有数据就醒来交换生产者与消费者对于的指针，唤醒消费者，消费者变处理数据，将数据发送到文件以及控制台上。
    
    但通常情况下，都是云存储中用户下载，上传，操作出错等系统会产生对应的日志，而非用户自己生产日志发送给异步日志系统。用户执行完某个操作，云存储系统响应后以json字符串的形式发送给异步日志系统。


## 建造者模型：
### 什么是建造者模式
建造者模式是一种对象创建型模式之一，用来隐藏复合对象的创建过程，他把复合对象的创建过程加以抽象，通过子类继承和重载的方式，动态地创建具有复合属性的对象。官方说法就是将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。

### 为什么使用建造者模式
主要解决在软件系统中，有时候面临着一个复杂对象的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将他们组合在一起的算法却相对稳定。

### 建造者模式实现步骤
1. 提供抽象建造者类: 为创建产品各个部分，统一抽象接口
2. 提供具体建造者类: 具体实现抽象创建者各个部分的接口
3. 提供多个具体产品类: 具体的创建产品的各个部分
4. 提供一个指挥类: 负责安排和调度复杂对象的各个建造过程


## AsyncLogger
- 包含一个异步日志器类和创建日志器的建造者

    ![](img/建造者模式.drawio.png)


## ThreadPool
- Thread 线程类：

    构造函数：接受来自线程池统一提供的线程函数
    ```cpp
    Thread(threadfunc func)
    {
        // 接受线程函数
        // 设置线程标识号：static 并自动增长。
    }
    ```

    启动函数：启动线程
    ```cpp
    void start()
    {
        // 创建并启动线程
        // 设置为分离线程
    }
    ```

- ThreadPool 线程池类：

    重要的参数列表：
        
    1. 初始线程数量(初始化的时候)`initThreadSize_`，上限线程数量`threadSizeThreshHold_`，当前线程数量`curThreadSize_`，空闲线程数量`idleThreadSize_`(疑似不需要)，线程列表(unordered_map, key为线程号)`threads_`
    2. 任务数量`taskSize_`，上限任务数量`taskQueMaxThreshHold_`，任务队列(queue)`taskQue_`
    3. 互斥和同步操作：
        
        a. 保证任务队列taskQue_线程安全的互斥锁`taskQueMtx_`
        
        b. 通知线程来取任务的`notEmpty_`, 表示线程有提交的任务

        c. 控制submitTask可以提交任务的`notFull_` 

    
    重要函数列表：
    1. 启动线程，按照设置的线程数量初始化线程，放入`threads_`，然后遍历注意启动（调用线程的`start()`函数）

    2. 线程函数，提供给Thread类的统一接口，内容为一个无限循环，wait等待任务队列不为空，苏醒并拿到锁后从队列中取出任务并执行

    3. 提交任务函数，用户调用这个函数来向线程池提交任务，有1s的超时判断，如果这一秒内任务队列都是满的就判定提交失败，否则写入任务队列中




